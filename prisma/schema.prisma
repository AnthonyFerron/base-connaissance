generator client {
  provider = "prisma-client-js"
  output   = "./generated"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String        @id @default(cuid())
  email         String        @unique
  role          Role          @default(USER)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  emailVerified Boolean?
  name          String?       @unique
  comments      Commentaire[]
  requests      Request[]
  accounts      Account[]
  sessions      Session[]

  @@map("user")
}

model Generation {
  id        Int       @id @default(autoincrement())
  nom       String    @unique
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  pokemons  Pokemon[]
}

model Type {
  id        Int       @id @default(autoincrement())
  image     String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  name      String    @unique
  color     String?
  pokemons  Pokemon[] @relation("PokemonToType")
  requests  Request[] @relation("RequestToType")
}

model Pokemon {
  id           Int           @id @default(autoincrement())
  photo        String
  generationId Int
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  name         String        @unique
  content      Json
  comments     Commentaire[]
  generation   Generation    @relation(fields: [generationId], references: [id])
  requests     Request[]
  types        Type[]        @relation("PokemonToType")

  @@index([generationId])
}

model Commentaire {
  id        Int      @id @default(autoincrement())
  texte     String
  createdAt DateTime @default(now())
  pokemonId Int
  authorId  String
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  pokemon   Pokemon  @relation(fields: [pokemonId], references: [id], onDelete: Cascade)

  @@index([authorId])
  @@index([pokemonId])
}

model Request {
  id           Int           @id @default(autoincrement())
  content      Json
  actionType   ActionType
  status       RequestStatus @default(EN_ATTENTE)
  proposedDate DateTime      @default(now())
  authorId     String
  pokemonId    Int
  name         String
  photo        String
  author       User          @relation(fields: [authorId], references: [id], onDelete: Cascade)
  pokemon      Pokemon       @relation(fields: [pokemonId], references: [id], onDelete: Cascade)
  types        Type[]        @relation("RequestToType")

  @@index([authorId])
  @@index([pokemonId])
  @@index([status])
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  password              String?
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("account")
}

enum Role {
  ADMIN
  USER
}

enum ActionType {
  AJOUT
  MODIFICATION
}

enum RequestStatus {
  EN_ATTENTE
  ACCEPTEE
  REFUSEE
}

model User {
  id            String   @id @default(cuid())
  name          String?  @unique
  email         String   @unique
  role          Role     @default(USER)
  emailVerified Boolean?

  comments Commentaire[]
  requests Request[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  sessions  Session[]
  accounts  Account[]

  @@map("user")
}

model Generation {
  id               Int    @id @default(autoincrement())
  name             String @unique
  generationNumber Int    @unique

  pokemons Pokemon[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Type {
  id    Int     @id @default(autoincrement())
  name  String  @unique
  image String?
  color String?

  pokemons Pokemon[]
  requests Request[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Pokemon {
  id      Int    @id @default(autoincrement())
  name    String @unique
  photo   String
  content Json

  generation   Generation @relation(fields: [generationId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  generationId Int

  types    Type[]
  comments Commentaire[]
  requests Request[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([generationId])
}

model Commentaire {
  id        Int      @id @default(autoincrement())
  text      String
  createdAt DateTime @default(now())

  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  authorId String

  pokemon   Pokemon @relation(fields: [pokemonId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  pokemonId Int

  @@index([authorId])
  @@index([pokemonId])
}

model Request {
  id           Int           @id @default(autoincrement())
  name         String
  photo        String
  types        Type[]
  content      Json
  actionType   ActionType
  status       RequestStatus @default(EN_ATTENTE)
  proposedDate DateTime      @default(now())

  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  authorId String

  pokemon   Pokemon? @relation(fields: [pokemonId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  pokemonId Int?

  @@index([authorId])
  @@index([pokemonId])
  @@index([status])
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("account")
}
